http {
  zookeeper              127.0.0.1:2181;
  zookeeper_log_level    debug;
  zookeeper_recv_timeout 5000;
  zookeeper_instances    /services/nginx 127.0.0.1:8080;

  server {
    listen 4444;

    default_type application/json;

    server_name zoo;

    location = /get {
      content_by_lua_block {
        local zoo = require "zoo"
        local cjson = require "cjson"

        local ok, value, err, stat = zoo.get(ngx.var.arg_znode)
        local r

        if ok then
          if not value then
            value = ""
          end
          r = { value = value, stat = stat }
        else
          r = { error = err }
        end

        ngx.say(cjson.encode(r))
      }
    }

    location = /childrens {
      content_by_lua_block {
        local zoo = require "zoo"
        local cjson = require "cjson"

        local ok, childs, err = zoo.childrens(ngx.var.arg_znode)
        local r

        if ok then
          r = childs
        else
          r = { error = err }
        end

        ngx.say(cjson.encode(r))
      }
    }

    location = /set {
      content_by_lua_block {
        local zoo = require "zoo"
        local cjson = require "cjson"

        local ok, err, stat = zoo.set(ngx.var.arg_znode, ngx.var.arg_value, ngx.var.arg_version)
        local r

        if ok then
          r = { value = ngx.var.arg_value, stat = stat }
        else
          r = { error = err }
        end

        ngx.say(cjson.encode(r))
      }
    }

    location = /create {
      content_by_lua_block {
        local zoo = require "zoo"
        local cjson = require "cjson"

        local ok, r, err = zoo.create(ngx.var.arg_znode, ngx.var.arg_value)

        if ok then
          r = { znode = r }
        else
          r = { error = err }
        end

        ngx.say(cjson.encode(r))
      }
    }

    location = /delete {
      content_by_lua_block {
        local zoo = require "zoo"
        local cjson = require "cjson"

        local ok, err = zoo.delete(ngx.var.arg_znode)
        if ok then
          r = { znode = "deleted" }
        else
          r = { error = err }
        end

        ngx.say(cjson.encode(r))
      }
    }

    location = /tree {
      content_by_lua_block {
        local zoo = require 'zoo'

        local subtree
        subtree = function(znode)
          local ok, value, err, stat = zoo.get(znode)
          if not ok then
            error(err)
          end

          if not value then
            value = ""
          end

          local tree = { value = value }

          if stat and ngx.var.arg_stat and ngx.var.arg_stat:match("[1yY]") then
            tree.stat = stat
          end

          if stat and stat.numChildren == 0 then
            return tree
          end

          local ok, childs, err = zoo.childrens(znode)
          if not ok then
            error(err)
          end

          if not znode:match("/$") then
            znode = znode .. "/"
          end

          for _, child in pairs(childs)
          do
            tree[child] = subtree(znode .. child)
          end

          return tree
        end

        local cjson = require "cjson"

        ngx.say(cjson.encode(subtree(ngx.var.arg_znode)))
      }
    }
  }
}
